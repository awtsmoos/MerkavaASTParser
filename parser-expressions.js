// In parser-expressions.js
// B"H --- Parsing Expressions [DEFINITIVE, UNIVERSAL & COMPLETE] ---
(function(proto) {
	proto.registerExpressionParsers=function(){const p=this.prefixParseFns,i=this.infixParseFns;p[TOKEN.IDENT]=this._parseIdentifier,p[TOKEN.NUMBER]=p[TOKEN.STRING]=p[TOKEN.TRUE]=p[TOKEN.FALSE]=p[TOKEN.NULL]=this._parseLiteral,p[TOKEN.THIS]=this._parseThisExpression,p[TOKEN.SUPER]=this._parseSuper,p[TOKEN.BANG]=p[TOKEN.MINUS]=p[TOKEN.PLUS]=p[TOKEN.TYPEOF]=p[TOKEN.AWAIT]=this._parsePrefixExpression,p[TOKEN.INCREMENT]=p[TOKEN.DECREMENT]=l=>this._parseUpdateExpression(l,!0),p[TOKEN.LPAREN]=this._parseGroupedOrArrowExpression,p[TOKEN.LBRACE]=this._parseObjectLiteral,p[TOKEN.LBRACKET]=this._parseArrayLiteral,p[TOKEN.TEMPLATE_HEAD]=p[TOKEN.TEMPLATE_TAIL]=this._parseTemplateLiteral,p[TOKEN.NEW]=this._parseNewExpression,p[TOKEN.FUNCTION]=this._parseFunctionExpression,p[TOKEN.CLASS]=this._parseClassExpression;const binary=l=>this._parseBinaryExpression(l);i[TOKEN.PLUS]=i[TOKEN.MINUS]=i[TOKEN.SLASH]=i[TOKEN.ASTERISK]=i[TOKEN.MODULO]=binary,i[TOKEN.EQ]=i[TOKEN.NOT_EQ]=i[TOKEN.EQ_STRICT]=i[TOKEN.NOT_EQ_STRICT]=binary,i[TOKEN.LT]=i[TOKEN.GT]=i[TOKEN.LTE]=i[TOKEN.GTE]=i[TOKEN.IN]=i[TOKEN.INSTANCEOF]=binary,i[TOKEN.AND]=i[TOKEN.OR]=i[TOKEN.NULLISH_COALESCING]=binary,i[TOKEN.EXPONENT]=binary,i[TOKEN.ASSIGN]=i[TOKEN.PLUS_ASSIGN]=i[TOKEN.MINUS_ASSIGN]=i[TOKEN.ASTERISK_ASSIGN]=i[TOKEN.SLASH_ASSIGN]=i[TOKEN.EXPONENT_ASSIGN]=i[TOKEN.MODULO_ASSIGN]=l=>this._parseAssignmentExpression(l),i[TOKEN.COMMA]=l=>this._parseSequenceExpression(l),i[TOKEN.INCREMENT]=i[TOKEN.DECREMENT]=l=>this._parseUpdateExpression(l,!1),i[TOKEN.LPAREN]=this._parseCallExpression,i[TOKEN.DOT]=this._parseMemberExpression,i[TOKEN.LBRACKET]=this._parseMemberExpression,i[TOKEN.OPTIONAL_CHAINING]=this._parseChainExpression,i[TOKEN.QUESTION]=this._parseConditionalExpression};
	
    // THIS IS THE UNBREAKABLE ENGINE. IT WILL NOT FREEZE.
	proto._parseExpression = function(precedence) {
	    let prefix = this.prefixParseFns[this.currToken.type];
	    if (!prefix) { this._error(`No prefix parse function for ${this.currToken.type}`); return null; }
	    let leftExp = prefix.call(this);
	
	    while (precedence < this._getPrecedence(this.currToken)) {
	        let infix = this.infixParseFns[this.currToken.type];
            
            // THIS IS THE GUARDIAN CLAUSE. It checks "Is this token actually an operator?"
            // At the end of a file, the token is EOF, `infix` is undefined, and this safely returns.
            // This single block prevents the infinite loop.
	        if (!infix) { return leftExp; }

	        leftExp = infix.call(this, leftExp);
	    }
	    return leftExp;
	};
	
	proto._parseIdentifier=function(){if(this._peekTokenIs(TOKEN.ARROW)){const t=this._startNode(),e={type:"Identifier",name:this.currToken.literal};this._advance();const s=this._finishNode(e,t);return this._parseArrowFunctionExpression(t,[s])}const t=this._startNode(),e={type:"Identifier",name:this.currToken.literal};return this._advance(),this._finishNode(e,t)};proto._parseLiteral=function(){const t=this._startNode(),e=this.currToken;let s=e.literal;e.type===TOKEN.NUMBER?s=parseFloat(s):e.type===TOKEN.TRUE?s=!0:e.type===TOKEN.FALSE?s=!1:e.type===TOKEN.NULL&&(s=null);const i={type:"Literal",value:s,raw:e.literal};return this._advance(),this._finishNode(i,t)};proto._parseThisExpression=function(){const t=this._startNode();return this._advance(),this._finishNode({type:"ThisExpression"},t)};proto._parseSuper=function(){const t=this._startNode();return this._advance(),this._finishNode({type:"Super"},t)};proto._parsePrefixExpression=function(){const t=this._startNode(),e=this.currToken.literal,s=this.currToken.type===TOKEN.AWAIT;this._advance();const i=this._parseExpression(PRECEDENCE.PREFIX),o=s?"AwaitExpression":"UnaryExpression";return this._finishNode({type:o,operator:e,argument:i,prefix:!0},t)};proto._parseUpdateExpression=function(t,e){const s=this._startNode();e?(t=this._parseIdentifier()):s.loc.start=t.loc.start;const i=this.currToken.literal;return this._advance(),this._finishNode({type:"UpdateExpression",operator:i,argument:t,prefix:e},s)};proto._parseGroupedOrArrowExpression=function(){const t=this._startNode();if(this._expect(TOKEN.LPAREN),this._currTokenIs(TOKEN.RPAREN))return this._expect(TOKEN.RPAREN),this._currTokenIs(TOKEN.ARROW)?this._parseArrowFunctionExpression(t,[]):(this._error("Unexpected empty parentheses."),null);const e=this._parseExpression(PRECEDENCE.LOWEST);return this._expect(TOKEN.RPAREN),this._currTokenIs(TOKEN.ARROW)?this._parseArrowFunctionExpression(t,"SequenceExpression"===e.type?e.expressions:[e]):e};proto._parseBinaryExpression=function(t){const e=this._startNode();e.loc.start=t.loc.start;const s=this.currToken.literal,i=this._getPrecedence(this.currToken);this._advance();const o=this._parseExpression(i);return this._finishNode({type:"BinaryExpression",operator:s,left:t,right:o},e)};proto._parseAssignmentExpression=function(t){if("Identifier"!==t.type&&"MemberExpression"!==t.type)return this._error("Invalid left-hand side in assignment."),null;const e=this._startNode();e.loc.start=t.loc.start;const s=this.currToken.literal;this._advance();const i=this._parseExpression(PRECEDENCE.ASSIGNMENT-1);return this._finishNode({type:"AssignmentExpression",operator:s,left:t,right:i},e)};proto._parseConditionalExpression=function(t){const e=this._startNode();e.loc.start=t.loc.start,this._advance();const s=this._parseExpression(PRECEDENCE.LOWEST);this._expect(TOKEN.COLON);const i=this._parseExpression(PRECEDENCE.LOWEST);return this._finishNode({type:"ConditionalExpression",test:t,consequent:s,alternate:i},e)};proto._parseSequenceExpression=function(t){const e=this._startNode();e.loc.start=t.loc.start;const s="SequenceExpression"===t.type?t.expressions:[t];return this._advance(),s.push(this._parseExpression(PRECEDENCE.SEQUENCE-1)),this._finishNode({type:"SequenceExpression",expressions:s},e)};proto._parseArrayLiteral=function(){const t=this._startNode();this._expect(TOKEN.LBRACKET);const e=[];for(;!this._currTokenIs(TOKEN.RBRACKET)&&!this._currTokenIs(TOKEN.EOF);){if(this._currTokenIs(TOKEN.COMMA)){this._advance(),e.push(null);continue}if(e.push(this._parseExpression(PRECEDENCE.ASSIGNMENT)),this._currTokenIs(TOKEN.COMMA))this._advance();else if(!this._currTokenIs(TOKEN.RBRACKET)){this._error("Expected comma or ']' after array element.");break}}return this._expect(TOKEN.RBRACKET),this._finishNode({type:"ArrayExpression",elements:e},t)};proto._parseObjectLiteral=function(){const t=this._startNode();this._expect(TOKEN.LBRACE);const e=[];for(;!this._currTokenIs(TOKEN.RBRACE)&&!this._currTokenIs(TOKEN.EOF);){if(e.push(this._parseObjectProperty()),this._currTokenIs(TOKEN.RBRACE))break;if(this._currTokenIs(TOKEN.COMMA))this._advance();else if(!this._currTokenIs(TOKEN.RBRACE)){this._error("Expected a comma between object properties.");break}}return this._expect(TOKEN.RBRACE),this._finishNode({type:"ObjectExpression",properties:e},t)};proto._parseObjectProperty=function(){const t=this._startNode();if(this._currTokenIs(TOKEN.DOTDOTDOT))return this._parseSpreadElement();let e=!1,s;if(this._currTokenIs(TOKEN.LBRACKET))e=!0,this._advance(),s=this._parseExpression(PRECEDENCE.LOWEST),this._expect(TOKEN.RBRACKET);else s=this.currToken.type===TOKEN.STRING||this.currToken.type===TOKEN.NUMBER?this._parseLiteral():this._parseIdentifier();if(this._currTokenIs(TOKEN.COLON)){this._expect(TOKEN.COLON);const i=this._parseExpression(PRECEDENCE.ASSIGNMENT);return this._finishNode({type:"Property",key:s,value:i,kind:"init",method:!1,shorthand:!1,computed:e},t)}return"Identifier"===s.type&&(this._currTokenIs(TOKEN.COMMA)||this._currTokenIs(TOKEN.RBRACE))?this._finishNode({type:"Property",key:s,value:s,kind:"init",method:!1,shorthand:!0,computed:!1},t):(this._error("Invalid object property syntax. Expected ':' or shorthand."),null)};proto._parseSpreadElement=function(){const t=this._startNode();this._expect(TOKEN.DOTDOTDOT);const e=this._parseExpression(PRECEDENCE.ASSIGNMENT);return this._finishNode({type:"SpreadElement",argument:e},t)};proto._parseArrowFunctionExpression=function(t,e){this._expect(TOKEN.ARROW);const s=this._currTokenIs(TOKEN.LBRACE)?this._parseBlockStatement():this._parseExpression(PRECEDENCE.ASSIGNMENT);return this._finishNode({type:"ArrowFunctionExpression",id:null,params:e,body:s,async:!1,expression:"BlockStatement"!==s.type},t)};proto._parseFunctionExpression=function(){return this._parseFunction("expression")};proto._parseClassExpression=function(){const t=this._startNode();this._expect(TOKEN.CLASS);let e=null;this._currTokenIs(TOKEN.IDENT)&&(e=this._parseIdentifier());let s=null;this._currTokenIs(TOKEN.EXTENDS)&&(this._advance(),s=this._parseIdentifier());const i=this._parseClassBody();return this._finishNode({type:"ClassExpression",id:e,superClass:s,body:i},t)};proto._parseNewExpression=function(){const t=this._startNode();this._expect(TOKEN.NEW);const e=this._parseExpression(PRECEDENCE.MEMBER);let s=[];return this._currTokenIs(TOKEN.LPAREN)&&(s=this._parseArgumentsList()),this._finishNode({type:"NewExpression",callee:e,arguments:s},t)};proto._parseCallExpression=function(t){const e=this._startNode();e.loc.start=t.loc.start;const s=this._parseArgumentsList();return this._finishNode({type:"CallExpression",callee:t,arguments:s,optional:!1},e)};proto._parseArgumentsList=function(){this._expect(TOKEN.LPAREN);const t=[];if(this._currTokenIs(TOKEN.RPAREN))return this._advance(),t;do t.push(this._parseExpression(PRECEDENCE.ASSIGNMENT));while(this._currTokenIs(TOKEN.COMMA)&&(this._advance(),!0));return this._expect(TOKEN.RPAREN),t};proto._parseMemberExpression=function(t,e=!1){const s=this._startNode();s.loc.start=t.loc.start;const i=this._currTokenIs(TOKEN.LBRACKET);this._advance();const o=i?this._parseExpression(PRECEDENCE.LOWEST):this._parseIdentifier();return i&&this._expect(TOKEN.RBRACKET),this._finishNode({type:"MemberExpression",object:t,property:o,computed:i,optional:e},s)};proto._parseChainExpression=function(t){const e=this._startNode();e.loc.start=t.loc.start,this._advance();let s=this._currTokenIs(TOKEN.LPAREN)?this._parseCallExpression(t):this._parseMemberExpression(t,!0);return"CallExpression"===s.type&&(s.optional=!0),this._finishNode({type:"ChainExpression",expression:s},e)};proto._parseTemplateLiteral=function(){const t=this._startNode(),e=[],s=[];let i=!1;for(;!i;){const o=this._startNode(),n={raw:this.currToken.literal,cooked:this.currToken.literal};if(i=this.currToken.type===TOKEN.TEMPLATE_TAIL,e.push(this._finishNode({type:"TemplateElement",value:n,tail:i},o)),this._advance(),!i&&(s.push(this._parseExpression(PRECEDENCE.LOWEST)),!this._currTokenIs(TOKEN.TEMPLATE_MIDDLE)&&!this._currTokenIs(TOKEN.TEMPLATE_TAIL)))return this._error("Unterminated template literal expression."),null}return this._finishNode({type:"TemplateLiteral",quasis:e,expressions:s},t)};
})(MerkabahParser.prototype);