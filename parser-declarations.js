// B"H --- Parsing Declarations ---
(function(proto) {
    proto.registerDeclarationParsers = function() { /* No registration needed */ };

    proto._parseDeclaration = function() {
        if (this._currTokenIs(TOKEN.SEMICOLON)) { this._advance(); return null; }
		switch (this.currToken.type) {
			case TOKEN.EXPORT: return this._parseExportDeclaration();
			case TOKEN.IMPORT: return this._parseImportDeclaration();
			case TOKEN.FUNCTION: return this._parseFunction('declaration');
			case TOKEN.CLASS: return this._parseClassDeclaration();
			case TOKEN.LET: case TOKEN.CONST: case TOKEN.VAR: return this._parseVariableDeclaration();
			case TOKEN.ASYNC: if (this._peekTokenIs(TOKEN.FUNCTION)) { this._advance(); return this._parseFunction('declaration', true); } return this._parseStatement();
			default: return this._parseStatement();
		}
	};

    proto._parseBindingPattern = function() { if (this._currTokenIs(TOKEN.LBRACE)) return this._parseObjectPattern(); if (this._currTokenIs(TOKEN.LBRACKET)) return this._parseArrayPattern(); return this._parseIdentifier(); };
    proto._parseObjectPattern = function() { const s = this._startNode(); const properties = []; this._advance(); while (!this._currTokenIs(TOKEN.RBRACE)) { properties.push(this._parseProperty()); if (this._currTokenIs(TOKEN.COMMA)) this._advance(); else break; } this._expect(TOKEN.RBRACE); return this._finishNode({ type: 'ObjectPattern', properties }, s); };
    proto._parseArrayPattern = function() { const s = this._startNode(); this._advance(); const elements = []; while (!this._currTokenIs(TOKEN.RBRACKET)) { if (this._currTokenIs(TOKEN.COMMA)) { elements.push(null); } else { elements.push(this._parseBindingPattern()); } if (this._currTokenIs(TOKEN.COMMA)) this._advance(); else break; } this._expect(TOKEN.RBRACKET); return this._finishNode({ type: 'ArrayPattern', elements }, s); };
    proto._parseVariableDeclaration = function() { const s = this._startNode(); const kind = this.currToken.literal; this._advance(); const declarations = []; do { const decl = this._parseVariableDeclarator(); if (decl) declarations.push(decl); } while (this._currTokenIs(TOKEN.COMMA) && (this._advance(), true)); if (declarations.length === 0) { this._error(`Variable declaration for "${kind}" must contain at least one declarator.`); return null; } this._consumeSemicolon(); return this._finishNode({ type: 'VariableDeclaration', declarations, kind }, s); };
    proto._parseVariableDeclarator = function() { const s = this._startNode(); const id = this._parseBindingPattern(); let init = null; if (this._currTokenIs(TOKEN.ASSIGN)) { this._advance(); init = this._parseExpression(PRECEDENCE.ASSIGNMENT); } if (!id) return null; return this._finishNode({ type: 'VariableDeclarator', id, init }, s); };
    proto._parseFunction = function(context, isAsync = false) { const s = this._startNode(); this._advance(); let id = null; if (this._currTokenIs(TOKEN.IDENT)) { id = this._parseIdentifier(); } else if (context === 'declaration') { this._error("Function declarations require a name"); } this._expect(TOKEN.LPAREN); const params = []; if (!this._currTokenIs(TOKEN.RPAREN)) { do { params.push(this._parseBindingPattern()); } while (this._currTokenIs(TOKEN.COMMA) && (this._advance(), true)); } this._expect(TOKEN.RPAREN); const body = this._parseBlockStatement(); const type = context === 'declaration' ? 'FunctionDeclaration' : 'FunctionExpression'; if (!body) return null; return this._finishNode({ type, id, params, body, async: isAsync, generator: false }, s); };
    proto._parseClassDeclaration = function() { const s = this._startNode(); this._advance(); const id = this._parseIdentifier(); let superClass = null; if (this._currTokenIs(TOKEN.EXTENDS)) { this._advance(); superClass = this._parseIdentifier(); } const body = this._parseClassBody(); if (!id || !body) return null; return this._finishNode({ type: 'ClassDeclaration', id, superClass, body }, s); };
    proto._parseClassBody = function() { const s = this._startNode(); this._expect(TOKEN.LBRACE); const body = []; while (!this._currTokenIs(TOKEN.RBRACE) && !this._currTokenIs(TOKEN.EOF)) { body.push(this._parseMethodDefinition()); } this._expect(TOKEN.RBRACE); return this._finishNode({ type: 'ClassBody', body }, s); };
    proto._parseMethodDefinition = function() { const s = this._startNode(); let isStatic = false; if (this.currToken.literal === 'static') { isStatic = true; this._advance(); } const key = this._parseIdentifier(); const value = this._parseFunction('expression'); if (!key || !value) return null; return this._finishNode({ type: 'MethodDefinition', key, value, kind: key.name === 'constructor' ? 'constructor' : 'method', 'static': isStatic }, s); };
    proto._parseImportDeclaration = function() { const s = this._startNode(); this._advance(); const specifiers = []; if (this._currTokenIs(TOKEN.STRING)) { const source = this._parseLiteral(); this._consumeSemicolon(); return this._finishNode({ type: 'ImportDeclaration', specifiers, source }, s); } if (this._currTokenIs(TOKEN.IDENT)) { specifiers.push(this._finishNode({ type: 'ImportDefaultSpecifier', local: this._parseIdentifier() }, this._startNode())); if (this._currTokenIs(TOKEN.COMMA)) this._advance(); } if (this._currTokenIs(TOKEN.ASTERISK)) { const ns_s = this._startNode(); this._advance(); this._expect(TOKEN.AS); const local = this._parseIdentifier(); specifiers.push(this._finishNode({ type: 'ImportNamespaceSpecifier', local }, ns_s)); } else if (this._currTokenIs(TOKEN.LBRACE)) { this._advance(); while (!this._currTokenIs(TOKEN.RBRACE)) { const spec_s = this._startNode(); const imported = this._parseIdentifier(); let local = imported; if (this._currTokenIs(TOKEN.AS)) { this._advance(); local = this._parseIdentifier(); } specifiers.push(this._finishNode({ type: 'ImportSpecifier', imported, local }, spec_s)); if (this._currTokenIs(TOKEN.COMMA)) this._advance(); else break; } this._expect(TOKEN.RBRACE); } if (specifiers.length === 0) this._error("Invalid import statement: expected specifiers."); this._expect(TOKEN.FROM); const source = this._parseLiteral(); this._consumeSemicolon(); if (!source) return null; return this._finishNode({ type: 'ImportDeclaration', specifiers, source }, s); };
    proto._parseExportDeclaration = function() { const s = this._startNode(); this._advance(); if (this._currTokenIs(TOKEN.DEFAULT)) { this._advance(); const declaration = this._parseExpression(PRECEDENCE.ASSIGNMENT); this._consumeSemicolon(); return this._finishNode({ type: 'ExportDefaultDeclaration', declaration }, s); } const declaration = this._parseDeclaration(); return this._finishNode({ type: 'ExportNamedDeclaration', declaration, specifiers: [], source: null }, s); };
})(MerkabahParser.prototype);