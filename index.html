<!--B"H-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kabbalistic ES6 AST Parser</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital@1&family=Roboto+Mono&display=swap');
        body { background-color: #1a1a1d; color: #c5c6c7; font-family: 'Roboto Mono', monospace; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        h1, h3 { font-family: 'Crimson Text', serif; color: #66fcf1; text-shadow: 0 0 5px #45a29e; text-align: center; }
        .container { display: flex; flex-direction: column; width: 90%; max-width: 1200px; gap: 20px; }
        .io-box { display: flex; flex-direction: column; width: 100%; }
        textarea, pre { background-color: #0b0c10; border: 1px solid #45a29e; color: #c5c6c7; padding: 15px; font-family: 'Roboto Mono', monospace; font-size: 14px; border-radius: 5px; height: 300px; resize: vertical; }
        pre { white-space: pre-wrap; word-wrap: break-word; overflow-y: auto; }
        .error { color: #ff6b6b !important; font-weight: bold; border-color: #ff6b6b !important; }
        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 15px; }
        button { background-color: #66fcf1; color: #0b0c10; border: none; padding: 10px 20px; cursor: pointer; font-size: 16px; font-weight: bold; border-radius: 5px; transition: background-color 0.3s ease, box-shadow 0.3s ease; }
        button:hover { background-color: #45a29e; box-shadow: 0 0 10px #66fcf1; }
        label { margin-bottom: 5px; font-size: 18px; color: #66fcf1; }
    </style>
</head>
<body>

    <h1>B"H Kabbalistic AST Parser</h1>
    <h3>Unveiling the hidden soul of ES6 JavaScript.</h3>

    <div class="container">
        <div class="io-box">
            <label for="js-input">Paste JavaScript Emanation Here:</label>
            <textarea id="js-input" spellcheck="false"></textarea>
        </div>
        
        <div class="controls">
            <button id="parse-btn">Parse the Emanation</button>
            <button id="copy-btn">Copy the Tree</button>
        </div>

        <div class="io-box">
             <label for="ast-output">Abstract Syntax Tree (The Unveiling):</label>
            <pre id="ast-output"></pre>
        </div>
    </div>
    
    <script type="awtsmoos" id="makor">
    
    //B"H

// The Omega Test: A script designed to break parsers.
export default class UltimateConfigurator {
  // 1. Private static field initialized with an Immediately-Invoked Generator Function Expression
  static #idGen = (function*() { let i = 0; while(true) yield i++; })();
  
  #id;
  #settings = new Map();
  onInit;

  // 2. The ultimate constructor: nested destructuring with arrow function defaults
  constructor({
    id = UltimateConfigurator.#idGen.next().value,
    onInit = async ({ customId = id } = {}) => {
      // 10. Async arrow function with its own destructured default parameter
      console.log(`Initializing with ID: ${customId}`);
      await new Promise(r => r());
      return { initialized: true };
    }
  } = {}) {
    this.#id = id;
    this.onInit = onInit;
  }

  // 3. An async method with try/catch and complex expressions
  async apply(config) {
    try {
      // 4. Optional chaining, nullish coalescing, and a ternary all at once
      const theme = config?.style?.theme ?? (config.legacy ? 'retro' : 'default');
      this.#settings.set('theme', theme);
      await this.onInit({ customId: this.#id });
    } catch(e) {
      console.error(`Failed to apply config for #${this.#id}: ${e?.message}`);
    }
  }

  // 5. A generator method that uses delegated yield and complex syntax
  * [Symbol.iterator]() {
    // 6. A for...of loop over a Map, with destructuring
    for (const [key, value] of this.#settings) {
      // 7. Yielding a template literal with a nested arrow function
      yield `[${key}]: ${(() => value?.toUpperCase() ?? 'N/A')()}`;
    }
    // 8. Delegated yield (yield*) to an array spread from the map's values
    yield* [...this.#settings.values()];
  }

  // 9. A getter for a private field
  get identifier() {
    return this.#id;
  }
}

// --- Execution of the Omega Test ---
(async () => {
  const config = new UltimateConfigurator();
  await config.apply({ style: { theme: null }, legacy: false });

  for (const setting of config) {
    console.log(setting);
  }
})();
    
    
    </script>
    
    <script type="Awtsmoos" id="makor2">
    
    // B"H --- The Keter Test: The Crown of Emanations ---
// A script designed to stress-test the deepest levels of a JS parser's consciousness.

// 1. Stress Point: Extending an Immediately-Invoked Class Expression.
// The parser must evaluate the expression `(class extends Array {...})` before assigning it as the superclass.
export default class TranscendentalReducer extends (class ChaosMatrix extends Array {
    // 2. Stress Point: Static initialization block, a newer ES feature.
    static {
        // Must parse dynamic import() as an expression, and handle top-level await's cousin.
        this.dynamicModule = import('https://some.module/path.js');
    }
    constructor(...args) { super(...(args.length ? args : [undefined])); }
}) {
    // 3. Stress Point: Private static field with a complex initializer using BigInt and RegExp.
    static #SEED = 1234567890123456789012345678901234567890n / BigInt(0o777);
    static #validator = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/gimsuy;

    // 4. Stress Point: Private instance fields and a getter/setter for a COMPUTED private field.
    #internalState;
    #computedPrivate = Symbol('secret');
    get [this.#computedPrivate]() { return this.#internalState; }
    set [this.#computedPrivate](val) { this.#internalState = val; }

    // 5. Stress Point: The ultimate constructor destructuring.
    // Deeply nested, aliased, with default values, and rest properties.
    constructor({
        id,
        metadata: { timestamp, tags: [firstTag, ...otherTags] = [] },
        config: { retries: retryCount = 3, params: { a: alpha = 1, b: beta = 2 } = {} }
    } = {}) {
        // 6. Stress Point: `super()` call with a ternary expression. `new.target` meta-property.
        super(id, new.target.name === 'TranscendentalReducer' ? 'VALID' : 'INVALID');
        this.#internalState = { timestamp, tags: { firstTag, otherTags }, retryCount, alpha, beta };
    }

    // 7. Stress Point: An async GENERATOR method.
    async * [Symbol.asyncIterator]() {
        let loopCount = 0;
        // 8. Stress Point: A labeled do-while loop.
        mainLoop:
        do {
            // 9. Stress Point: `for await...of` loop with DESTRUCTURING and default BigInt values.
            for await (const [{ prop: renamed = 999n }, ...rest] of this.#sourceGenerator()) {
                if (!renamed) break mainLoop; // Test `break` with a label.
                
                // 10. Stress Point: Tagged template literal inside a nested ternary.
                const processed = TranscendentalReducer.#tagFn `Value: ${
                    rest.length > 0 ? rest[0]?.value ?? 'fallback' : 'empty'
                }`;

                // 11. Stress Point: Delegated yield to another async generator.
                yield* this.#processChunk({ renamed, processed, seed: TranscendentalReducer.#SEED });
            }
        } while (loopCount++ < this.#internalState.retryCount);
    }
    
    // 12. Stress Point: A simple static method for the tagged template literal.
    static #tagFn(strings, ...values) {
        return strings[0] + String(values[0]).toUpperCase();
    }
    
    // Helper async generator.
    async * #sourceGenerator() {
        yield [{ prop: 'data1' }, { value: 100 }];
        yield [{}]; // Yield an object without the 'prop' to test the default value.
    }
    
    // Another helper async generator.
    async * #processChunk(chunk) {
        await new Promise(r => setTimeout(r, 10));
        yield chunk;
    }
}

// 13. Stress Point: Immediately-invoked async function to run the test.
(async () => {
    try {
        const instance = new TranscendentalReducer({
            id: 'keter-01',
            metadata: { timestamp: Date.now(), tags: ['a', 'b', 'c'] },
            config: { retries: 2, params: { a: 5 } }
        });

        for await (const finalChunk of instance) {
            console.log('Final Chunk:', finalChunk);
        }
    } catch (e) {
        console.error('The Keter Test Failed:', e);
    }
})();
    
    
    </script>
    
    <!-- Load scripts in the correct, required order -->
    <script src="constants.js"></script>
    <script src="Lexer.js"></script>

    <!-- The core parser MUST be loaded first -->
    <script src="parser-core.js"></script>

    <!-- Load the component files that extend the parser's prototype -->
    <script src="parser-expressions.js"></script>
    <script src="parser-statements.js"></script>
    <script src="parser-declarations.js"></script>
    
   <!-- In index.html -->
<script>
var makor=document. getElementById("makor2")
    document.addEventListener('DOMContentLoaded', () => {
        const jsInput = document.getElementById('js-input');
        const astOutput = document.getElementById('ast-output');
        const parseButton = document.getElementById('parse-btn');
        const copyButton = document.getElementById('copy-btn');

        // This is the simple, correct, and robust way to run the parser.
        // It creates a new instance every time, ensuring a perfectly clean state.
        const runParser = () => {
            astOutput.textContent = '';
            astOutput.classList.remove('error');
            const sourceCode = jsInput.value;
            
            // Re-create the parser from scratch on every run.
            // This is clean and avoids all the state issues and race conditions.
            const parser = new MerkabahParser(sourceCode);
            
            // The registration functions MUST be called on the new instance
            // to attach the parsing logic from the component files.
            parser.registerExpressionParsers();
            parser.registerStatementParsers();
            parser.registerDeclarationParsers();

            // Now, parse.
            const ast = parser.parse();

            if (parser.errors.length > 0) {
                const errorMessage = "The vessels have shattered. The following transgressions were observed:\n\n" + parser.errors.join('\n');
                astOutput.textContent = errorMessage;
                astOutput.classList.add('error');
            } else {
                astOutput.textContent = JSON.stringify(ast, null, 2);
            }
        };

        const copyAstToClipboard = () => {
            if (!astOutput.textContent || astOutput.classList.contains('error')) {
                alert('There is no valid AST to copy.');
                return;
            }
            navigator.clipboard.writeText(astOutput.textContent)
                .then(() => alert('AST copied to clipboard!'))
                .catch(err => {
                    console.error('Failed to copy AST: ', err);
                    alert('Could not copy AST. See the console for details.');
                });
        };

        parseButton.addEventListener('click', runParser);
        copyButton.addEventListener('click', copyAstToClipboard);

        jsInput.value = makor.innerHTML
        
       // `var f = 3;`;
        runParser();
    });
</script>

</body>
</html>